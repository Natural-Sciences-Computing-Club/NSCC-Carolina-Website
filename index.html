<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NSCC - Natural Sciences Computing Club</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none;
        }
        
        :root {
            /* Golden Ratio Constants */
            --phi: 1.618;
            --phi-inv: 0.618;
            
            /* Fibonacci-based sizing system (vh units) */
            --fib-1: 1vh;
            --fib-2: 1.5vh;
            --fib-3: 2.5vh;
            --fib-5: 4vh;
            --fib-8: 6.5vh;
            --fib-13: 10.5vh;
            --fib-21: 17vh;
            --fib-34: 27.5vh;
            --fib-55: 44.5vh;
            
            /* Color System */
            --chrome: linear-gradient(135deg, #ffffff, #e8f4f8, #d0e7f0);
            --glass-white: rgba(255, 255, 255, 0.1);
            --glass-blue: rgba(200, 230, 255, 0.08);
            --neural-blue: #a8d5e8;
            --accent-cyan: #7ec8e3;
            --text-dark: #2a3f4d;
            --text-light: #5a7a8c;
            
            /* Golden Ratio Positions */
            --golden-x1: 38.2%;
            --golden-x2: 61.8%;
            --golden-y1: 38.2%;
            --golden-y2: 61.8%;
            
            /* Rule of Thirds */
            --third-1: 33.33%;
            --third-2: 66.67%;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(180deg, #f0f0f0 0%, #e1eff8 50%, #d1e3f0 100%);
            color: var(--text-dark);
            overflow: hidden;
            height: 100vh;
            position: relative;
            perspective: 3000px;
            perspective-origin: 50% 50%;
        }
        
        /* Chrome Grid Floor - Behind everything */
        .chrome-grid {
            position: fixed;
            width: 161.8%;
            height: 161.8%;
            top: 61.8%;
            left: 50%;
            transform: translateX(-50%) rotateX(70deg) translateZ(-500px);
            background-image: 
                repeating-linear-gradient(0deg, 
                    transparent, 
                    transparent calc(var(--fib-21) * 2.5), 
                    rgba(255,255,255,0.08) calc(var(--fib-21) * 2.5), 
                    rgba(255,255,255,0.08) calc(var(--fib-21) * 2.5 + 1px)),
                repeating-linear-gradient(90deg, 
                    transparent, 
                    transparent calc(var(--fib-21) * 2.5), 
                    rgba(255,255,255,0.08) calc(var(--fib-21) * 2.5), 
                    rgba(255,255,255,0.08) calc(var(--fib-21) * 2.5 + 1px));
            opacity: 0.3;
            animation: grid-pulse 21s ease-in-out infinite;
            z-index: 1;
            pointer-events: none;
        }
        
        @keyframes grid-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.15; }
        }
        
        /* Organic Nebula System */
        .organic-nebula {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 2;
            pointer-events: none;
        }
        
        .nebula-blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(calc(var(--fib-13) * 3));
            will-change: transform;
        }
        
        /* Primary Blob - Golden Ratio Focus */
        .blob-primary {
            width: var(--fib-55);
            height: var(--fib-55);
            background: radial-gradient(circle at 38.2% 38.2%, 
                rgba(126,200,227,0.4) 0%, 
                rgba(126,200,227,0.2) 38.2%,
                rgba(126,200,227,0.05) 61.8%,
                transparent 100%);
            left: calc(var(--golden-x2) - var(--fib-55) / 2);
            top: calc(var(--golden-y1) - var(--fib-55) / 2);
            animation: blob-drift-primary 89s infinite ease-in-out;
        }
        
        /* Secondary Blob - Complementary Position */
        .blob-secondary {
            width: var(--fib-34);
            height: var(--fib-34);
            background: radial-gradient(circle at 61.8% 61.8%, 
                rgba(168,213,232,0.35) 0%,
                rgba(168,213,232,0.15) 50%, 
                transparent 100%);
            left: calc(var(--golden-x1) - var(--fib-34) / 2);
            top: calc(var(--golden-y2) - var(--fib-34) / 2);
            animation: blob-drift-secondary 55s infinite ease-in-out reverse;
        }
        
        /* Tertiary Blob - Balance Point */
        .blob-tertiary {
            width: calc(var(--fib-34) * 1.272);
            height: calc(var(--fib-34) * 1.272);
            background: radial-gradient(circle at 50% 50%, 
                rgba(200,230,255,0.3) 0%,
                rgba(200,230,255,0.1) 38.2%,
                transparent 61.8%);
            left: calc(var(--third-2) - var(--fib-21));
            top: calc(var(--third-2) - var(--fib-21));
            animation: blob-drift-tertiary 72s infinite ease-in-out;
        }
        
        /* Accent Blobs - Fibonacci Sizing */
        .blob-accent-1 {
            width: var(--fib-21);
            height: var(--fib-21);
            background: radial-gradient(circle, 
                rgba(126,200,227,0.25) 0%, 
                transparent 61.8%);
            left: 14.6%;
            top: 23.6%;
            animation: blob-orbit-1 34s infinite ease-in-out;
        }
        
        .blob-accent-2 {
            width: var(--fib-13);
            height: var(--fib-13);
            background: radial-gradient(circle, 
                rgba(200,230,255,0.2) 0%, 
                transparent 50%);
            right: 9%;
            bottom: 14.6%;
            animation: blob-orbit-2 21s infinite ease-in-out reverse;
        }
        
        /* Blob Animations */
        @keyframes blob-drift-primary {
            0%, 100% { 
                transform: translate(0, 0) scale(1) rotate(0deg); 
            }
            16.18% {
                transform: translate(calc(var(--fib-8) * -1), var(--fib-5)) scale(1.05) rotate(61.8deg); 
            }
            38.2% { 
                transform: translate(var(--fib-5), calc(var(--fib-8) * -1)) scale(0.95) rotate(137deg); 
            }
            61.8% { 
                transform: translate(calc(var(--fib-5) * -1), var(--fib-8)) scale(1.08) rotate(222.5deg); 
            }
            85.4% { 
                transform: translate(var(--fib-8), var(--fib-3)) scale(0.97) rotate(300deg); 
            }
        }
        
        @keyframes blob-drift-secondary {
            0%, 100% { 
                transform: translate(0, 0) scale(1); 
            }
            25% { 
                transform: translate(calc(var(--fib-13) * -1), calc(var(--fib-8) * -1)) scale(1.1); 
            }
            50% { 
                transform: translate(var(--fib-8), calc(var(--fib-13) * -1)) scale(0.9); 
            }
            75% { 
                transform: translate(calc(var(--fib-5) * -1), var(--fib-13)) scale(1.05); 
            }
        }
        
        @keyframes blob-drift-tertiary {
            0%, 100% { 
                transform: translate(0, 0) scale(1) rotate(0deg); 
            }
            20% { 
                transform: translate(calc(var(--fib-8) * 1.618), calc(var(--fib-5) * -1.618)) scale(0.94) rotate(72deg); 
            }
            40% { 
                transform: translate(calc(var(--fib-5) * -1.618), calc(var(--fib-8) * 1.618)) scale(1.06) rotate(144deg); 
            }
            60% { 
                transform: translate(calc(var(--fib-8) * -0.618), calc(var(--fib-5) * -1.618)) scale(0.98) rotate(216deg); 
            }
            80% { 
                transform: translate(calc(var(--fib-5) * 1.618), calc(var(--fib-8) * 0.618)) scale(1.03) rotate(288deg); 
            }
        }
        
        @keyframes blob-orbit-1 {
            0%, 100% { 
                transform: translate(0, 0) scale(1); 
            }
            50% { 
                transform: translate(var(--fib-21), calc(var(--fib-13) * -1)) scale(1.15); 
            }
        }
        
        @keyframes blob-orbit-2 {
            0%, 100% { 
                transform: translate(0, 0) scale(1); 
            }
            50% { 
                transform: translate(calc(var(--fib-13) * -1), var(--fib-21)) scale(0.85); 
            }
        }
        
        /* WebGL Canvas */
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }
        
        /* Cyberspace Container */
        .cyberspace {
            position: fixed;
            width: 100vw;
            height: 100vh;
            transform-style: preserve-3d;
            animation: space-breathe 144s infinite ease-in-out;
            z-index: 4;
            pointer-events: none;
        }
        
        @keyframes space-breathe {
            0%, 100% { transform: rotateY(-8deg) rotateX(-3deg) scale(1); }
            23.6% { transform: rotateY(5deg) rotateX(2deg) scale(1.02); }
            38.2% { transform: rotateY(-5deg) rotateX(3deg) scale(0.98); }
            61.8% { transform: rotateY(8deg) rotateX(-2deg) scale(1.01); }
            76.4% { transform: rotateY(-3deg) rotateX(1deg) scale(0.99); }
        }
        
        /* Shape Clusters */
        .shape-cluster {
            position: absolute;
            transform-style: preserve-3d;
            will-change: transform;
            pointer-events: none;
            z-index: 2;
            opacity: 0.7;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        
        /* Primary Dodecahedron */
        .cluster-primary {
            left: calc(var(--golden-x2) - var(--fib-21) / 2);
            top: calc(var(--golden-y1) - var(--fib-21) / 2);
            animation: cluster-float-primary 55s infinite ease-in-out;
        }
        
        .dodecahedron {
            position: relative;
            width: var(--fib-34);
            height: var(--fib-34);
            transform-style: preserve-3d;
            animation: dodeca-spin 89s infinite linear;
        }
        
        .dodeca-face {
            position: absolute;
            width: 100px;
            height: 100px;
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
        }
        
        @keyframes dodeca-spin {
            0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
            100% { transform: rotateX(360deg) rotateY(720deg) rotateZ(360deg); }
        }
        
        @keyframes cluster-float-primary {
            0%, 100% { transform: translate3d(0, 0, 0); }
            38.2% { transform: translate3d(var(--fib-8), calc(var(--fib-5) * -1), var(--fib-13)); }
            61.8% { transform: translate3d(calc(var(--fib-5) * -1), var(--fib-8), calc(var(--fib-8) * -1)); }
        }
        
        /* Secondary Icosahedron */
        .cluster-secondary {
            left: calc(var(--golden-x1) - var(--fib-13) / 2);
            top: calc(var(--golden-y2) - var(--fib-13) / 2);
            animation: cluster-float-secondary 34s infinite ease-in-out reverse;
        }
        
        .icosahedron {
            position: relative;
            width: var(--fib-21);
            height: var(--fib-21);
            transform-style: preserve-3d;
            animation: ico-spin 55s infinite linear reverse;
        }
        
        .ico-face {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 75px solid transparent;
            border-right: 75px solid transparent;
            border-bottom: 130px solid rgba(255,255,255,0.08);
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.2),
                rgba(200,230,255,0.15),
                rgba(126,200,227,0.08));
            background-clip: padding-box;
            backdrop-filter: blur(10px);
            opacity: 0.5;
        }
        
        @keyframes ico-spin {
            0% { transform: rotateX(0deg) rotateY(0deg) scale(1); }
            50% { transform: rotateX(180deg) rotateY(360deg) scale(1.1); }
            100% { transform: rotateX(360deg) rotateY(720deg) scale(1); }
        }
        
        @keyframes cluster-float-secondary {
            0%, 100% { transform: translate3d(0, 0, 0) scale(1); }
            50% { transform: translate3d(calc(var(--fib-13) * -1), var(--fib-8), var(--fib-5)) scale(0.9); }
        }
        
        /* Torus */
        .cluster-tertiary {
            right: calc(100% - var(--golden-x2) - var(--fib-21));
            bottom: calc(100% - var(--golden-y2) - var(--fib-21));
            animation: cluster-float-tertiary 89s infinite ease-in-out;
        }
        
        .torus {
            position: relative;
            width: calc(var(--fib-21) * 1.272);
            height: calc(var(--fib-21) * 1.272);
            border-radius: 50%;
            border: calc(var(--fib-8) * 0.618) solid transparent;
            background: linear-gradient(45deg, 
                #ffffff 0%,
                #e8f4f8 23.6%,
                #d0e7f0 38.2%,
                #c0c0c0 61.8%,
                #ffffff 100%);
            background-size: 161.8% 161.8%;
            background-clip: padding-box;
            backdrop-filter: blur(calc(var(--fib-5) * 2));
            transform-style: preserve-3d;
            animation: 
                torus-rotate 34s infinite linear,
                chrome-flow 8s infinite linear;
            box-shadow: 
                inset 0 0 var(--fib-13) rgba(126,200,227,0.3),
                0 0 var(--fib-21) rgba(126,200,227,0.15);
        }
        
        @keyframes torus-rotate {
            from { transform: rotateX(0deg) rotateY(0deg); }
            to { transform: rotateX(360deg) rotateY(360deg); }
        }
        
        @keyframes chrome-flow {
            0% { background-position: 0% 0%; }
            100% { background-position: 161.8% 161.8%; }
        }
        
        @keyframes cluster-float-tertiary {
            0%, 100% { transform: translate3d(0, 0, 0); }
            33.33% { transform: translate3d(var(--fib-13), var(--fib-8), calc(var(--fib-5) * -1)); }
            66.67% { transform: translate3d(calc(var(--fib-8) * -1), calc(var(--fib-13) * -1), var(--fib-8)); }
        }
        
        /* Octahedron */
        .cluster-quaternary {
            left: var(--third-2);
            top: var(--third-1);
            animation: cluster-float-quaternary 21s infinite ease-in-out;
        }
        
        .octahedron {
            position: relative;
            width: var(--fib-13);
            height: var(--fib-13);
            transform-style: preserve-3d;
            animation: octa-tumble 34s infinite linear;
        }
        
        .octa-face {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 60px solid transparent;
            border-right: 60px solid transparent;
            border-bottom: 104px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            opacity: 0.6;
        }
        
        @keyframes octa-tumble {
            from { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
            to { transform: rotateX(-360deg) rotateY(360deg) rotateZ(-360deg); }
        }
        
        @keyframes cluster-float-quaternary {
            0%, 100% { transform: translate3d(0, 0, 0) scale(1); }
            50% { transform: translate3d(calc(var(--fib-8) * -1.618), var(--fib-13), var(--fib-5)) scale(1.1); }
        }
        
        /* DNA Helix */
        .dna-helix {
            position: absolute;
            width: calc(var(--fib-13) * 1.618);
            height: calc(var(--fib-55) * 1.272);
            right: 9%;
            top: 38.2%;
            transform-style: preserve-3d;
            animation: helix-rotate 55s infinite linear;
            opacity: 0.4;
            z-index: 2;
        }
        
        @keyframes helix-rotate {
            from { transform: rotateY(0deg) translateZ(-50px); }
            to { transform: rotateY(360deg) translateZ(-50px); }
        }
        
        /* Glass Layer Materials */
        .glass-layer-1 {
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.1) 0%,
                rgba(200,230,255,0.05) 38.2%,
                rgba(255,255,255,0.03) 61.8%,
                rgba(126,200,227,0.06) 85.4%,
                rgba(255,255,255,0.08) 100%);
            backdrop-filter: blur(calc(var(--fib-5) * 3));
            border: 0.5px solid rgba(255,255,255,0.2);
            box-shadow: 
                inset 0 0 var(--fib-8) rgba(255,255,255,0.05),
                0 0 var(--fib-13) rgba(200,230,255,0.1);
        }
        
        .glass-layer-2 {
            background: linear-gradient(45deg,
                rgba(255,255,255,0.06) 0%,
                transparent 38.2%,
                rgba(200,230,255,0.03) 61.8%,
                rgba(255,255,255,0.05) 100%);
            backdrop-filter: blur(calc(var(--fib-5) * 2));
            border: 1px solid rgba(200,230,255,0.15);
        }
        
        /* Neural Network */
        .neural-network {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 6;
        }
        
        /* Data Streams */
        .data-stream {
            position: absolute;
            width: 2px;
            background: linear-gradient(180deg, 
                transparent 0%, 
                var(--accent-cyan) 14.6%, 
                var(--accent-cyan) 85.4%, 
                transparent 100%);
            opacity: 0;
            transform-origin: top;
            animation: data-flow 5s linear infinite;
            box-shadow: 
                0 0 var(--fib-8) var(--accent-cyan), 
                0 0 var(--fib-13) var(--accent-cyan);
            z-index: 7;
        }
        
        @keyframes data-flow {
            0% {
                opacity: 0;
                transform: scaleY(0);
            }
            14.6% {
                opacity: 0.8;
            }
            85.4% {
                opacity: 0.8;
            }
            100% {
                opacity: 0;
                transform: scaleY(1);
            }
        }
        
        /* Chrome Title */
        .chrome-title {
            position: absolute;
            top: 10%;
            left: 0;
            right: 0;
            text-align: center;
            transform: translateZ(200px);
            font-size: 120px;
            font-weight: 100;
            letter-spacing: 30px;
            background: linear-gradient(90deg,
                #d9d9d9 0%,
                #c1d9e6 12.5%,
                #86b0d9 25%,
                #5189c0 37.5%,
                #86b0d9 50%,
                #c1d9e6 62.5%,
                #d9d9d9 75%,
                #c1d9e6 87.5%,
                #86b0d9 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 
                0 2px 10px rgba(255,255,255,0.8),
                0 10px 30px rgba(126,200,227,0.3);
            transform-style: preserve-3d;
            animation: chrome-text-flow 12s linear infinite;
            pointer-events: none;
            z-index: 50;
        }
        
        @keyframes chrome-text-flow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        
        .subtitle {
            position: absolute;
            top: 22%;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 14px;
            letter-spacing: 8px;
            color: var(--text-light);
            font-weight: 200;
            text-transform: uppercase;
            opacity: 0.764;
            pointer-events: none;
            z-index: 50;
        }
        
        /* Navigation Panels */
        .nav-panel {
            position: fixed;
            width: 15vw;
            min-width: 180px;
            height: 30vh;
            min-height: 240px;
            transform-style: preserve-3d;
            transition: none;
            cursor: move;
            pointer-events: auto;
            z-index: 1000;
            will-change: transform;
        }
        
        .nav-panel.dragging {
            z-index: 2000;
            filter: brightness(1.2);
        }
        
        /* Y2K Aero Glass Panel Container */
        .panel-glass-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.8),
                inset 0 -2px 4px rgba(0,0,0,0.2),
                0 0 0 1px rgba(255,255,255,0.5),
                0 10px 40px rgba(0,0,0,0.3),
                0 2px 10px rgba(0,0,0,0.2);
        }
        
        .panel-glass-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 20px;
            pointer-events: none;
        }
        
        .panel-hologram {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.382s;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(126,200,227,0.03) 2px,
                rgba(126,200,227,0.03) 4px
            );
            animation: hologram-scan 2.618s linear infinite;
        }
        
        @keyframes hologram-scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        
        .nav-panel:hover .panel-hologram {
            opacity: 1;
        }
        
        /* Glass Layer Effects */
        .panel-glass-base {
            background: linear-gradient(180deg,
                rgba(255,255,255,0.4) 0%,
                rgba(255,255,255,0.15) 3.82%,
                rgba(255,255,255,0.05) 14.6%,
                rgba(255,255,255,0.02) 61.8%,
                rgba(0,0,0,0.05) 100%);
            backdrop-filter: blur(40px) saturate(1.618) brightness(1.1);
            -webkit-backdrop-filter: blur(40px) saturate(1.618) brightness(1.1);
            border: 1px solid transparent;
            border-image: linear-gradient(180deg,
                rgba(255,255,255,0.8) 0%,
                rgba(255,255,255,0.2) 50%,
                rgba(0,0,0,0.1) 100%) 1;
        }
        
        .panel-glass-gloss {
            background: linear-gradient(180deg,
                rgba(255,255,255,0.6) 0%,
                rgba(255,255,255,0.3) 2.36%,
                rgba(255,255,255,0.1) 6.18%,
                transparent 38.2%);
            mix-blend-mode: overlay;
        }
        
        .panel-glass-reflection {
            background: radial-gradient(ellipse at 50% -14.6%,
                rgba(255,255,255,0.5) 0%,
                rgba(255,255,255,0.2) 23.6%,
                transparent 61.8%);
            transform: scaleY(0.618);
            opacity: 0.8;
            mix-blend-mode: screen;
        }
        
        .panel-glass-refraction {
            background-image: 
                radial-gradient(circle at 38.2% 38.2%, 
                    rgba(255,255,255,0.2) 0%, 
                    transparent 23.6%),
                radial-gradient(circle at 61.8% 61.8%, 
                    rgba(200,230,255,0.15) 0%, 
                    transparent 38.2%),
                radial-gradient(circle at 23.6% 76.4%, 
                    rgba(255,255,255,0.1) 0%, 
                    transparent 38.2%);
            filter: blur(1px);
            animation: refraction-shift 21s infinite ease-in-out;
        }
        
        .panel-glass-caustics {
            background-image: 
                radial-gradient(ellipse at 23.6% 38.2%, rgba(126,200,227,0.15) 0%, transparent 38.2%),
                radial-gradient(ellipse at 61.8% 61.8%, rgba(168,213,232,0.12) 0%, transparent 38.2%),
                radial-gradient(ellipse at 76.4% 23.6%, rgba(200,230,255,0.1) 0%, transparent 38.2%);
            animation: caustic-dance 34s infinite linear;
            mix-blend-mode: add;
            opacity: 0.618;
        }
        
        .panel-glass-bands {
            background-image: repeating-linear-gradient(180deg,
                transparent,
                transparent 20px,
                rgba(255,255,255,0.03) 20px,
                rgba(255,255,255,0.03) 21px,
                transparent 21px,
                transparent 40px,
                rgba(0,0,0,0.02) 40px,
                rgba(0,0,0,0.02) 41px);
            opacity: 0.5;
        }
        
        @keyframes refraction-shift {
            0%, 100% { transform: translateY(0); }
            61.8% { transform: translateY(10px); }
        }
        
        @keyframes caustic-dance {
            0% { transform: rotate(0deg) scale(1); }
            38.2% { transform: rotate(137deg) scale(1.1); }
            61.8% { transform: rotate(222.5deg) scale(0.95); }
            100% { transform: rotate(360deg) scale(1); }
        }
        
        .panel-content {
            position: relative;
            padding: 25px;
            height: 100%;
            z-index: 1;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        }
        
        .panel-icon {
            width: 60px;
            height: 60px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--neural-blue));
            clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
            animation: icon-rotate 13s infinite linear;
        }
        
        @keyframes icon-rotate {
            from { transform: rotateZ(0deg); }
            to { transform: rotateZ(360deg); }
        }
        
        .panel-title {
            font-size: 24px;
            font-weight: 200;
            margin-bottom: 15px;
            color: var(--text-dark);
            letter-spacing: 2px;
        }
        
        .panel-description {
            font-size: 12px;
            line-height: 1.618;
            color: var(--text-light);
            opacity: 0.854;
        }
        
        .panel-data {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.618;
        }
        
        /* Chrome Cursor */
        .chrome-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 100000;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
        }
        
        .cursor-core {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.9) 0%,
                rgba(255,255,255,0.5) 38.2%,
                transparent 61.8%);
            border-radius: 50%;
            filter: blur(2px);
        }
        
        .cursor-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            animation: cursor-pulse 1.618s infinite;
        }
        
        @keyframes cursor-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            61.8% { transform: scale(1.618); opacity: 0; }
        }
        
        /* Deformation Ripple */
        .deformation-ripple {
            position: fixed;
            width: 600px;
            height: 600px;
            pointer-events: none;
            opacity: 0;
            transform: translate(-50%, -50%);
            transition: opacity 0.382s;
            z-index: 10;
        }
        
        .deformation-ripple.active {
            opacity: 1;
        }
        
        .deformation-ripple::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid var(--accent-cyan);
            border-radius: 50%;
            animation: ripple-expand 1.618s ease-out infinite;
        }
        
        @keyframes ripple-expand {
            0% {
                transform: scale(0.146);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0;
            }
        }
        
        /* Glitch Effect */
        .glitch-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 9999;
            mix-blend-mode: screen;
        }
        
        /* Debug Panel */
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100000;
            max-width: 300px;
            display: none;
        }
        
        /* Design Grid */
        .design-grid {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
        }
        
        .golden-point {
            position: absolute;
            width: 2px;
            height: 2px;
            background: red;
            transform: translate(-50%, -50%);
        }
        
        .golden-point.primary { left: var(--golden-x2); top: var(--golden-y1); }
        .golden-point.secondary { left: var(--golden-x1); top: var(--golden-y2); }
        .golden-point.tertiary { left: var(--golden-x2); top: var(--golden-y2); }
        .golden-point.quaternary { left: var(--golden-x1); top: var(--golden-y1); }
        
        /* Expanded Container System - Advanced Morphing Animation */
        /* IMPORTANT: Background elements (nebula, chrome grid, 3D objects) always remain visible */
        .expanded-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5000;
            pointer-events: none;
            /* Completely transparent to show background - NO OPACITY OR BACKGROUND COLOR */
            background: transparent;
        }
        
        .expanded-overlay.active {
            pointer-events: auto;
        }
        
        /* Morphing Container */
        .expanded-container {
            position: fixed;
            /* Initial state matches panel size */
            width: 15vw;
            min-width: 180px;
            height: 30vh;
            min-height: 240px;
            z-index: 5001;
            transform-style: preserve-3d;
            transform-origin: center center;
            pointer-events: none;
            opacity: 0;
            /* Custom transition for smooth morphing */
            transition: none; /* Will be set via JS for precise control */
            will-change: transform, width, height, left, top, opacity;
        }
        
        .expanded-container.morphing {
            opacity: 1;
            transition: 
                left 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                top 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                width 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                height 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .expanded-container.expanded {
            /* Final expanded state - 5.5% margins */
            width: 89% !important;
            height: 89% !important;
            left: 5.5% !important;
            top: 5.5% !important;
            pointer-events: auto;
        }
        
        /* Glass Container with Consistent Styling */
        .expanded-glass-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 20px;
            overflow: hidden;
            /* Exact same initial shadow as panels */
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.8),
                inset 0 -2px 4px rgba(0,0,0,0.2),
                0 0 0 1px rgba(255,255,255,0.5),
                0 10px 40px rgba(0,0,0,0.3),
                0 2px 10px rgba(0,0,0,0.2);
            /* Transition for shadow enhancement on expansion */
            transition: box-shadow 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            /* No solid background - glass effect only */
            background: transparent;
        }
        
        .expanded-container.expanded .expanded-glass-container {
            /* Enhanced shadow when expanded */
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.8),
                inset 0 -2px 4px rgba(0,0,0,0.2),
                0 0 0 1px rgba(255,255,255,0.5),
                0 20px 60px rgba(0,0,0,0.4),
                0 5px 20px rgba(0,0,0,0.3);
        }
        
        .expanded-glass-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 20px;
            pointer-events: none;
        }
        
        /* Exact panel glass base styling */
        .expanded-glass-base {
            background: linear-gradient(180deg,
                rgba(255,255,255,0.4) 0%,
                rgba(255,255,255,0.15) 3.82%,
                rgba(255,255,255,0.05) 14.6%,
                rgba(255,255,255,0.02) 61.8%,
                rgba(0,0,0,0.05) 100%);
            backdrop-filter: blur(40px) saturate(1.618) brightness(1.1);
            -webkit-backdrop-filter: blur(40px) saturate(1.618) brightness(1.1);
            border: 1px solid transparent;
            border-image: linear-gradient(180deg,
                rgba(255,255,255,0.8) 0%,
                rgba(255,255,255,0.2) 50%,
                rgba(0,0,0,0.1) 100%) 1;
        }
        
        /* Expanded Content with Delayed Fade */
        .expanded-content {
            position: relative;
            padding: 50px;
            z-index: 1;
            pointer-events: auto;
            opacity: 0;
            transform: translateY(20px);
            transition: 
                opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            /* Scrollable content */
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            /* Very subtle glass background for readability */
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(2px);
            border-radius: 20px;
        }
        
        .expanded-container.expanded .expanded-content {
            opacity: 1;
            transform: translateY(0);
            transition: 
                opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.3s,
                transform 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.3s;
        }
        
        /* Custom Scrollbar for Expanded Content */
        .expanded-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .expanded-content::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }
        
        .expanded-content::-webkit-scrollbar-thumb {
            background: rgba(126,200,227,0.5);
            border-radius: 10px;
        }
        
        .expanded-content::-webkit-scrollbar-thumb:hover {
            background: rgba(126,200,227,0.7);
        }
        
        /* Close Button with Fade Animation */
        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg,
                rgba(255,255,255,0.3),
                rgba(255,255,255,0.15));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            font-size: 24px;
            color: var(--text-dark);
            font-weight: 200;
            opacity: 0;
            transform: scale(0.8) rotate(-90deg);
            transition: 
                all 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.5s,
                transform 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.5s;
        }
        
        .expanded-container.expanded .close-btn {
            opacity: 1;
            transform: scale(1) rotate(0deg);
        }
        
        .close-btn:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 0 30px rgba(126,200,227,0.6);
            background: linear-gradient(135deg,
                rgba(126,200,227,0.4),
                rgba(126,200,227,0.2));
            color: white;
        }
        
        /* Fade Out Elements */
        .fade-element {
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            /* Maintain transform during fade to prevent jumping */
            will-change: opacity;
        }
        
        .fade-element.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        /* Leadership Content Styling */
        .expanded-title {
            font-size: 48px;
            font-weight: 200;
            color: var(--text-dark);
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: 4px;
        }
        
        .leader-section {
            display: flex;
            align-items: center;
            gap: 40px;
            margin-bottom: 50px;
            padding: 30px;
            border-radius: 15px;
            background: linear-gradient(135deg,
                rgba(255,255,255,0.1),
                rgba(200,230,255,0.05));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .leader-image-left {
            flex: 0 0 30%;
            order: 1;
        }
        
        .leader-image-right {
            flex: 0 0 30%;
            order: 2;
        }
        
        .leader-info-left {
            flex: 0 0 calc(70% - 40px);
            order: 2;
        }
        
        .leader-info-right {
            flex: 0 0 calc(70% - 40px);
            order: 1;
        }
        
        .leader-image {
            width: 100%;
            aspect-ratio: 3/4;
            background: linear-gradient(135deg,
                rgba(126,200,227,0.3),
                rgba(168,213,232,0.2));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-light);
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
        }
        
        .leader-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .leader-role {
            font-size: 14px;
            font-weight: 300;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }
        
        .leader-name {
            font-size: 28px;
            font-weight: 300;
            color: var(--text-dark);
            margin-bottom: 15px;
            letter-spacing: 1px;
        }
        
        .leader-description {
            font-size: 14px;
            line-height: 1.8;
            color: var(--text-light);
            opacity: 0.9;
        }
        
        .bottom-link {
            text-align: center;
            margin-top: 60px;
            padding-top: 30px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        
        .bottom-link a {
            display: inline-block;
            padding: 15px 40px;
            background: linear-gradient(135deg,
                rgba(126,200,227,0.3),
                rgba(126,200,227,0.2));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 30px;
            color: var(--text-dark);
            text-decoration: none;
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            transition: all 0.3s;
        }
        
        .bottom-link a:hover {
            background: linear-gradient(135deg,
                rgba(126,200,227,0.5),
                rgba(126,200,227,0.3));
            box-shadow: 0 0 30px rgba(126,200,227,0.4);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <!-- Debug Panel -->
    <div id="debug">Loading Three.js...</div>
    
    <!-- Design Grid (for development) -->
    <div class="design-grid">
        <div class="golden-point primary"></div>
        <div class="golden-point secondary"></div>
        <div class="golden-point tertiary"></div>
        <div class="golden-point quaternary"></div>
    </div>
    
    <!-- Expanded Container Overlay -->
    <div class="expanded-overlay" id="expandedOverlay">
        <div class="expanded-container" id="expandedContainer">
            <div class="expanded-glass-container">
                <div class="expanded-glass-layer expanded-glass-base"></div>
                <div class="expanded-glass-layer panel-glass-gloss"></div>
                <div class="expanded-glass-layer panel-glass-reflection"></div>
                <div class="expanded-glass-layer panel-glass-refraction"></div>
                <div class="expanded-glass-layer panel-glass-caustics"></div>
                <div class="expanded-glass-layer panel-glass-bands"></div>
                <button class="close-btn" id="closeBtn" onclick="collapsePanel()">×</button>
                <div class="expanded-content" id="expandedContent">
                    <!-- Content will be dynamically inserted here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Chrome Grid Floor -->
    <div class="chrome-grid"></div>
    
    <!-- Organic Nebula Background -->
    <div class="organic-nebula">
        <div class="nebula-blob blob-primary"></div>
        <div class="nebula-blob blob-secondary"></div>
        <div class="nebula-blob blob-tertiary"></div>
        <div class="nebula-blob blob-accent-1"></div>
        <div class="nebula-blob blob-accent-2"></div>
    </div>
    
    <!-- Three.js Canvas -->
    <canvas id="three-canvas"></canvas>
    
    <!-- Deformation Ripple Effect -->
    <div class="deformation-ripple" id="deformationRipple"></div>
    
    <!-- Glitch Effect Overlay -->
    <div class="glitch-effect" id="glitchEffect"></div>
    
    <!-- Chrome Cursor -->
    <div class="chrome-cursor" id="chromeCursor">
        <div class="cursor-core"></div>
        <div class="cursor-ring"></div>
    </div>
    
    <!-- Neural Network -->
    <div class="neural-network" id="neuralNetwork"></div>
    
    <!-- Cyberspace Container -->
    <div class="cyberspace" id="cyberspace">
        
        <!-- Chrome Title -->
        <h1 class="chrome-title fade-element" id="siteTitle">NSCC</h1>
        <p class="subtitle fade-element" id="siteSubtitle">Natural Sciences Computing Club</p>
        
        <!-- Primary Dodecahedron Cluster -->
        <div class="shape-cluster cluster-primary">
            <div class="dodecahedron">
                <div class="dodeca-face glass-layer-1" style="transform: rotateY(0deg) translateZ(100px);"></div>
                <div class="dodeca-face glass-layer-2" style="transform: rotateY(72deg) translateZ(100px);"></div>
                <div class="dodeca-face glass-layer-1" style="transform: rotateY(144deg) translateZ(100px);"></div>
            </div>
        </div>
        
        <!-- Secondary Icosahedron Cluster -->
        <div class="shape-cluster cluster-secondary">
            <div class="icosahedron">
                <div class="ico-face" style="transform: rotateX(0deg) rotateY(0deg) translateZ(75px);"></div>
                <div class="ico-face" style="transform: rotateX(60deg) rotateY(0deg) translateZ(75px);"></div>
                <div class="ico-face" style="transform: rotateX(120deg) rotateY(0deg) translateZ(75px);"></div>
            </div>
        </div>
        
        <!-- Tertiary Torus Cluster -->
        <div class="shape-cluster cluster-tertiary">
            <div class="torus"></div>
        </div>
        
        <!-- Quaternary Octahedron Cluster -->
        <div class="shape-cluster cluster-quaternary">
            <div class="octahedron">
                <div class="octa-face glass-layer-2" style="transform: rotateY(0deg) rotateX(35deg) translateZ(50px);"></div>
                <div class="octa-face glass-layer-1" style="transform: rotateY(90deg) rotateX(35deg) translateZ(50px);"></div>
            </div>
        </div>
        
        <!-- DNA Helix -->
        <div class="dna-helix"></div>
        
        <!-- Data Streams -->
        <div class="data-stream" id="dataStream1"></div>
        <div class="data-stream" id="dataStream2"></div>
        <div class="data-stream" id="dataStream3"></div>
        
        <!-- Navigation Panels -->
        <div class="nav-panel fade-element" id="panel1" data-original-x="5" data-original-y="35" data-content-type="research">
            <div class="panel-glass-container">
                <div class="panel-glass-layer panel-glass-base"></div>
                <div class="panel-glass-layer panel-glass-gloss"></div>
                <div class="panel-glass-layer panel-glass-reflection"></div>
                <div class="panel-glass-layer panel-glass-refraction"></div>
                <div class="panel-glass-layer panel-glass-caustics"></div>
                <div class="panel-glass-layer panel-glass-bands"></div>
                <div class="panel-hologram"></div>
                <div class="panel-content">
                    <div class="panel-icon"></div>
                    <h2 class="panel-title">Research</h2>
                    <p class="panel-description">
                        Cross-disciplinary projects in climate modeling, protein folding, 
                        and epidemiological simulations.
                    </p>
                    <div class="panel-data">
                        <span>12 PROJECTS</span>
                        <span>ACTIVE</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="nav-panel fade-element" id="panel2" data-original-x="77" data-original-y="30" data-content-type="workshops">
            <div class="panel-glass-container">
                <div class="panel-glass-layer panel-glass-base"></div>
                <div class="panel-glass-layer panel-glass-gloss"></div>
                <div class="panel-glass-layer panel-glass-reflection"></div>
                <div class="panel-glass-layer panel-glass-refraction"></div>
                <div class="panel-glass-layer panel-glass-caustics"></div>
                <div class="panel-glass-layer panel-glass-bands"></div>
                <div class="panel-hologram"></div>
                <div class="panel-content">
                    <div class="panel-icon"></div>
                    <h2 class="panel-title">Workshops</h2>
                    <p class="panel-description">
                        Weekly sessions teaching Python, data analysis, and scientific 
                        computing tools.
                    </p>
                    <div class="panel-data">
                        <span>EVERY MONDAY</span>
                        <span>ALL LEVELS</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="nav-panel fade-element" id="panel3" data-original-x="41" data-original-y="55" data-content-type="community">
            <div class="panel-glass-container">
                <div class="panel-glass-layer panel-glass-base"></div>
                <div class="panel-glass-layer panel-glass-gloss"></div>
                <div class="panel-glass-layer panel-glass-reflection"></div>
                <div class="panel-glass-layer panel-glass-refraction"></div>
                <div class="panel-glass-layer panel-glass-caustics"></div>
                <div class="panel-glass-layer panel-glass-bands"></div>
                <div class="panel-hologram"></div>
                <div class="panel-content">
                    <div class="panel-icon"></div>
                    <h2 class="panel-title">Community</h2>
                    <p class="panel-description">
                        Connect with students across biology, chemistry, physics, and 
                        environmental sciences.
                    </p>
                    <div class="panel-data">
                        <span>87 MEMBERS</span>
                        <span>GROWING</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="nav-panel fade-element" id="panel4" data-original-x="23" data-original-y="30" data-content-type="join">
            <div class="panel-glass-container">
                <div class="panel-glass-layer panel-glass-base"></div>
                <div class="panel-glass-layer panel-glass-gloss"></div>
                <div class="panel-glass-layer panel-glass-reflection"></div>
                <div class="panel-glass-layer panel-glass-refraction"></div>
                <div class="panel-glass-layer panel-glass-caustics"></div>
                <div class="panel-glass-layer panel-glass-bands"></div>
                <div class="panel-hologram"></div>
                <div class="panel-content">
                    <div class="panel-icon"></div>
                    <h2 class="panel-title">Join Us</h2>
                    <p class="panel-description">
                        Open to all UNC students interested in computational science. 
                        No prior programming experience required.
                    </p>
                    <div class="panel-data">
                        <span>APPLY NOW</span>
                        <span>OPEN</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="nav-panel fade-element" id="panel5" data-original-x="59" data-original-y="55" data-content-type="leadership">
            <div class="panel-glass-container">
                <div class="panel-glass-layer panel-glass-base"></div>
                <div class="panel-glass-layer panel-glass-gloss"></div>
                <div class="panel-glass-layer panel-glass-reflection"></div>
                <div class="panel-glass-layer panel-glass-refraction"></div>
                <div class="panel-glass-layer panel-glass-caustics"></div>
                <div class="panel-glass-layer panel-glass-bands"></div>
                <div class="panel-hologram"></div>
                <div class="panel-content">
                    <div class="panel-icon"></div>
                    <h2 class="panel-title">Leadership</h2>
                    <p class="panel-description">
                        Meet our executive team and project leads. Opportunities for 
                        leadership roles.
                    </p>
                    <div class="panel-data">
                        <span>8 POSITIONS</span>
                        <span>2024-2025</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Golden Ratio Cybercore System
        const PHI = 1.618033988749;
        const PHI_INV = 0.618033988749;
        const FIBONACCI = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
        
        let scene, camera, renderer, clock;
        let structures = [];
        let particles = null;
        let mouseX = 0, mouseY = 0;
        let structuresVisible = true;
        let particlesVisible = true;
        let harmonicMotion, panelPhysics, dataStreamController;
        
        const debug = document.getElementById('debug');
        function log(msg) {
            if (debug.style.display !== 'none') {
                debug.innerHTML = msg + '<br>' + debug.innerHTML;
            }
            console.log(msg);
        }
        
        // Performance Monitor (internal tracking only)
        const perfMonitor = {
            fps: 60,
            objectCount: 0,
            startTime: performance.now(),
            frames: 0,
            update: function() {
                this.frames++;
                const currentTime = performance.now();
                const elapsed = currentTime - this.startTime;
                if (elapsed >= 1000) {
                    this.fps = Math.round((this.frames * 1000) / elapsed);
                    this.frames = 0;
                    this.startTime = currentTime;
                }
            }
        };
        
        // Harmonic Motion System
        class HarmonicMotionSystem {
            constructor() {
                this.time = 0;
                this.elements = new Map();
                this.frameCounter = 0;
                this.updateFrequency = 2;
            }
            
            registerElement(element, config) {
                this.elements.set(element, {
                    amplitude: config.amplitude || PHI * 10,
                    frequency: config.frequency || 1 / (PHI * 10),
                    phase: config.phase || Math.random() * Math.PI * 2,
                    axis: config.axis || 'y',
                    pattern: config.pattern || 'sine',
                    lissajousA: 3,
                    lissajousB: 5,
                    perlinFactors: [1, PHI, PHI * PHI],
                    perlinDivisor: 1.75
                });
            }
            
            update(deltaTime) {
                this.time += deltaTime;
                this.frameCounter++;
                
                if (this.frameCounter % this.updateFrequency !== 0) return;
                
                this.elements.forEach((config, element) => {
                    if (!element.visible) return;
                    
                    const t = this.time * config.frequency + config.phase;
                    let displacement = 0;
                    
                    switch(config.pattern) {
                        case 'sine':
                            displacement = Math.sin(t) * config.amplitude;
                            break;
                        case 'lissajous':
                            displacement = Math.sin(config.lissajousA * t) * config.amplitude;
                            break;
                        case 'perlin':
                            displacement = (Math.sin(t) + Math.sin(t * config.perlinFactors[1]) * 0.5 + 
                                         Math.sin(t * config.perlinFactors[2]) * 0.25) * config.amplitude / config.perlinDivisor;
                            break;
                    }
                    
                    if (element.position && element.userData.originalPosition) {
                        element.position[config.axis] = element.userData.originalPosition[config.axis] + displacement;
                    }
                });
            }
        }
        
        // Panel Physics Engine
        class GoldenPanelPhysics {
            constructor() {
                this.panels = new Map();
                this.constraints = [];
                this.draggedPanel = null;
                this.initialized = false;
                this.frameCounter = 0;
                this.updateFrequency = 2;
                this.lastWidth = window.innerWidth;
                this.lastHeight = window.innerHeight;
                
                this.springConstants = {
                    stiffness: PHI_INV * 0.1,
                    damping: PHI_INV,
                    restLength: 0,
                    minVelocity: 0.01
                };
                
                setTimeout(() => this.initializePanels(), 100);
            }
            
            initializePanels() {
                if (this.initialized) return;
                this.initialized = true;
                
                document.querySelectorAll('.nav-panel').forEach((panel) => {
                    const dataX = parseFloat(panel.dataset.originalX);
                    const dataY = parseFloat(panel.dataset.originalY);
                    
                    const x = (dataX / 100) * window.innerWidth;
                    const y = (dataY / 100) * window.innerHeight;
                    
                    const panelData = {
                        element: panel,
                        position: { x, y },
                        velocity: { x: 0, y: 0 },
                        originalPosition: { x, y },
                        angle: 0,
                        angularVelocity: 0,
                        isDragging: false,
                        isMoving: false,
                        mass: PHI
                    };
                    
                    this.panels.set(panel.id, panelData);
                    
                    this.constraints.push({
                        type: 'spring',
                        panel: panel.id,
                        anchor: { x, y },
                        stiffness: this.springConstants.stiffness,
                        damping: this.springConstants.damping,
                        restLength: 0
                    });
                    
                    panel.style.left = '0px';
                    panel.style.top = '0px';
                    panel.style.transform = `translate3d(${x}px, ${y}px, 0)`;
                    panel.style.willChange = 'transform';
                    
                    this.addPanelListeners(panel);
                });
            }
            
            addPanelListeners(panel) {
                let offsetX, offsetY;
                let velocityTracking = [];
                let mouseDownTime = 0;
                let mouseDownX = 0;
                let mouseDownY = 0;
                let hasMoved = false;
                
                panel.addEventListener('mousedown', (e) => {
                    const panelData = this.panels.get(panel.id);
                    if (!panelData) return;
                    
                    // Record mouse down time and position for click detection
                    mouseDownTime = Date.now();
                    mouseDownX = e.clientX;
                    mouseDownY = e.clientY;
                    hasMoved = false;
                    
                    this.draggedPanel = panel.id;
                    panelData.isDragging = true;
                    panelData.isMoving = true;
                    panel.classList.add('dragging');
                    
                    const rect = panel.getBoundingClientRect();
                    offsetX = e.clientX - rect.left;
                    offsetY = e.clientY - rect.top;
                    velocityTracking = [];
                    
                    panelData.velocity.x = 0;
                    panelData.velocity.y = 0;
                    panelData.angularVelocity = 0;
                    
                    e.preventDefault();
                });
                
                const handleMouseMove = (e) => {
                    if (this.draggedPanel !== panel.id) return;
                    
                    const panelData = this.panels.get(panel.id);
                    if (!panelData || !panelData.isDragging) return;
                    
                    // Check if mouse moved significantly
                    const dx = e.clientX - mouseDownX;
                    const dy = e.clientY - mouseDownY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 5) {
                        hasMoved = true;
                    }
                    
                    const newX = e.clientX - offsetX;
                    const newY = e.clientY - offsetY;
                    
                    velocityTracking.push({ 
                        x: newX - panelData.position.x, 
                        y: newY - panelData.position.y 
                    });
                    if (velocityTracking.length > 5) velocityTracking.shift();
                    
                    panelData.position.x = newX;
                    panelData.position.y = newY;
                    
                    panel.style.transform = `translate3d(${newX}px, ${newY}px, 0) rotateZ(${panelData.angle}deg)`;
                };
                
                const handleMouseUp = (e) => {
                    if (this.draggedPanel !== panel.id) return;
                    
                    const panelData = this.panels.get(panel.id);
                    if (!panelData) return;
                    
                    panel.classList.remove('dragging');
                    panelData.isDragging = false;
                    
                    // Check if this was a click (short time, no movement)
                    const clickDuration = Date.now() - mouseDownTime;
                    const isClick = !hasMoved && clickDuration < 200;
                    
                    if (isClick) {
                        // This was a click, trigger panel expansion
                        const contentType = panel.dataset.contentType;
                        if (contentType && !isExpanded) {
                            expandPanel(panel.id, contentType);
                        }
                    } else {
                        // This was a drag, apply physics
                        if (velocityTracking.length > 0) {
                            const avgVel = velocityTracking.reduce((acc, vel) => ({
                                x: acc.x + vel.x,
                                y: acc.y + vel.y
                            }), { x: 0, y: 0 });
                            
                            panelData.velocity.x = (avgVel.x / velocityTracking.length) * PHI_INV;
                            panelData.velocity.y = (avgVel.y / velocityTracking.length) * PHI_INV;
                            panelData.angularVelocity = panelData.velocity.x * (1 / PHI) * 0.1;
                        }
                    }
                    
                    this.draggedPanel = null;
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            }
            
            update(deltaTime) {
                if (!this.initialized) return;
                
                this.frameCounter++;
                
                if (this.frameCounter % this.updateFrequency !== 0) return;
                
                deltaTime = Math.min(deltaTime * this.updateFrequency, 1 / 30);
                
                this.panels.forEach((panelData, panelId) => {
                    if (panelData.isDragging) return;
                    
                    if (!panelData.isMoving) return;
                    
                    this.constraints.forEach(constraint => {
                        if (constraint.panel === panelId) {
                            const dx = constraint.anchor.x - panelData.position.x;
                            const dy = constraint.anchor.y - panelData.position.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 5) {
                                const springForceX = dx * constraint.stiffness;
                                const springForceY = dy * constraint.stiffness;
                                
                                panelData.velocity.x += springForceX / panelData.mass;
                                panelData.velocity.y += springForceY / panelData.mass;
                            }
                        }
                    });
                    
                    panelData.velocity.x *= this.springConstants.damping;
                    panelData.velocity.y *= this.springConstants.damping;
                    
                    if (Math.abs(panelData.velocity.x) < this.springConstants.minVelocity && 
                        Math.abs(panelData.velocity.y) < this.springConstants.minVelocity) {
                        panelData.velocity.x = 0;
                        panelData.velocity.y = 0;
                        panelData.isMoving = false;
                        panelData.angularVelocity = 0;
                        panelData.angle = 0;
                        return;
                    } else {
                        panelData.isMoving = true;
                    }
                    
                    panelData.position.x += panelData.velocity.x;
                    panelData.position.y += panelData.velocity.y;
                    
                    panelData.angularVelocity *= PHI_INV;
                    panelData.angle += panelData.angularVelocity;
                    panelData.angle *= (1 + PHI_INV) / 2;
                    
                    panelData.element.style.transform = 
                        `translate3d(${panelData.position.x}px, ${panelData.position.y}px, 0) 
                         rotateZ(${panelData.angle}deg)`;
                });
                
                // Continuously check for overlaps during physics updates
                this.checkCollisionsDuringPhysics();
            }
            
            checkCollisionsDuringPhysics() {
                const panelArray = Array.from(this.panels.values());
                const panelWidth = window.innerWidth * 0.15;
                const panelHeight = window.innerHeight * 0.30;
                const minWidth = 180;
                const minHeight = 240;
                
                const actualWidth = Math.max(panelWidth, minWidth);
                const actualHeight = Math.max(panelHeight, minHeight);
                
                for (let i = 0; i < panelArray.length; i++) {
                    for (let j = i + 1; j < panelArray.length; j++) {
                        const a = panelArray[i];
                        const b = panelArray[j];
                        
                        if (a.isDragging || b.isDragging) continue;
                        
                        const dx = b.position.x - a.position.x;
                        const dy = b.position.y - a.position.y;
                        
                        // Check if too close
                        if (Math.abs(dx) < actualWidth && Math.abs(dy) < actualHeight) {
                            // Apply repulsion force
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < actualWidth * 0.8) {
                                const repulsionStrength = 0.5;
                                const angle = Math.atan2(dy, dx);
                                
                                if (!a.isMoving) a.isMoving = true;
                                if (!b.isMoving) b.isMoving = true;
                                
                                a.velocity.x -= Math.cos(angle) * repulsionStrength;
                                a.velocity.y -= Math.sin(angle) * repulsionStrength;
                                b.velocity.x += Math.cos(angle) * repulsionStrength;
                                b.velocity.y += Math.sin(angle) * repulsionStrength;
                            }
                        }
                    }
                }
            }
            
            updateBounds() {
                const oldWidth = this.lastWidth;
                const oldHeight = this.lastHeight;
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;
                
                const scaleX = newWidth / oldWidth;
                const scaleY = newHeight / oldHeight;
                
                this.panels.forEach((panelData) => {
                    const panel = panelData.element;
                    const dataX = parseFloat(panel.dataset.originalX);
                    const dataY = parseFloat(panel.dataset.originalY);
                    
                    // Calculate new anchor positions from percentages
                    const newAnchorX = (dataX / 100) * newWidth;
                    const newAnchorY = (dataY / 100) * newHeight;
                    
                    // Scale current position proportionally
                    panelData.position.x *= scaleX;
                    panelData.position.y *= scaleY;
                    
                    // Update original position
                    panelData.originalPosition.x = newAnchorX;
                    panelData.originalPosition.y = newAnchorY;
                    
                    // Update constraints
                    this.constraints.forEach(constraint => {
                        if (constraint.panel === panel.id) {
                            constraint.anchor.x = newAnchorX;
                            constraint.anchor.y = newAnchorY;
                        }
                    });
                    
                    // Immediately update transform
                    panel.style.transform = 
                        `translate3d(${panelData.position.x}px, ${panelData.position.y}px, 0) 
                         rotateZ(${panelData.angle}deg)`;
                });
                
                // Prevent overlaps after scaling
                this.resolveOverlaps();
                
                // Store dimensions for next resize
                this.lastWidth = newWidth;
                this.lastHeight = newHeight;
            }
            
            resolveOverlaps() {
                const panelArray = Array.from(this.panels.values());
                // Use actual panel dimensions with some padding
                const panelWidth = window.innerWidth * 0.15; // 15vw
                const panelHeight = window.innerHeight * 0.30; // 30vh
                const minWidth = 180;
                const minHeight = 240;
                
                const actualWidth = Math.max(panelWidth, minWidth);
                const actualHeight = Math.max(panelHeight, minHeight);
                const padding = 20; // Minimum space between panels
                
                // Multiple passes to resolve all overlaps
                for (let pass = 0; pass < 3; pass++) {
                    for (let i = 0; i < panelArray.length; i++) {
                        for (let j = i + 1; j < panelArray.length; j++) {
                            const a = panelArray[i];
                            const b = panelArray[j];
                            
                            // Skip if either is being dragged
                            if (a.isDragging || b.isDragging) continue;
                            
                            const dx = b.position.x - a.position.x;
                            const dy = b.position.y - a.position.y;
                            
                            const minDistX = actualWidth + padding;
                            const minDistY = actualHeight + padding;
                            
                            // Check if overlapping
                            if (Math.abs(dx) < minDistX && Math.abs(dy) < minDistY) {
                                // Calculate overlap amounts
                                const overlapX = minDistX - Math.abs(dx);
                                const overlapY = minDistY - Math.abs(dy);
                                
                                // Push apart along axis of least overlap
                                if (overlapX < overlapY) {
                                    // Separate horizontally
                                    const pushX = (overlapX / 2 + padding) * Math.sign(dx || 1);
                                    a.position.x -= pushX;
                                    b.position.x += pushX;
                                } else {
                                    // Separate vertically
                                    const pushY = (overlapY / 2 + padding) * Math.sign(dy || 1);
                                    a.position.y -= pushY;
                                    b.position.y += pushY;
                                }
                                
                                // Keep panels on screen
                                const maxX = window.innerWidth - actualWidth;
                                const maxY = window.innerHeight - actualHeight;
                                
                                a.position.x = Math.max(0, Math.min(a.position.x, maxX));
                                a.position.y = Math.max(0, Math.min(a.position.y, maxY));
                                b.position.x = Math.max(0, Math.min(b.position.x, maxX));
                                b.position.y = Math.max(0, Math.min(b.position.y, maxY));
                                
                                // Update transforms immediately
                                a.element.style.transform = 
                                    `translate3d(${a.position.x}px, ${a.position.y}px, 0) rotateZ(${a.angle}deg)`;
                                b.element.style.transform = 
                                    `translate3d(${b.position.x}px, ${b.position.y}px, 0) rotateZ(${b.angle}deg)`;
                            }
                        }
                    }
                }
            }
        }
        
        // Data Stream Controller
        class DataStreamController {
            constructor() {
                this.streams = [];
                this.updateStreams();
            }
            
            updateStreams() {
                const panels = document.querySelectorAll('.nav-panel');
                const cyberspace = document.getElementById('cyberspace');
                
                document.querySelectorAll('.data-stream').forEach(s => s.remove());
                this.streams = [];
                
                const connections = [
                    [0, 2],
                    [1, 3],
                    [2, 4],
                    [3, 0],
                    [4, 1]
                ];
                
                connections.forEach(([from, to], index) => {
                    if (panels[from] && panels[to]) {
                        const rect1 = panels[from].getBoundingClientRect();
                        const rect2 = panels[to].getBoundingClientRect();
                        
                        const stream = document.createElement('div');
                        stream.className = 'data-stream';
                        stream.id = `dataStream${index}`;
                        
                        const dx = rect2.left + rect2.width / 2 - (rect1.left + rect1.width / 2);
                        const dy = rect2.top + rect2.height / 2 - (rect1.top + rect1.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        stream.style.width = '2px';
                        stream.style.height = distance + 'px';
                        stream.style.left = (rect1.left + rect1.width / 2) + 'px';
                        stream.style.top = (rect1.top + rect1.height / 2) + 'px';
                        stream.style.transform = `rotate(${angle + 90}deg)`;
                        stream.style.transformOrigin = 'top center';
                        stream.style.animationDelay = `${index * PHI_INV}s`;
                        
                        cyberspace.appendChild(stream);
                        this.streams.push(stream);
                    }
                });
            }
        }
        
        // Three.js Initialization
        function checkThreeJS() {
            if (typeof THREE !== 'undefined') {
                log('Three.js loaded successfully');
                init();
            } else {
                log('Waiting for Three.js...');
                setTimeout(checkThreeJS, 100);
            }
        }
        
        function init() {
            try {
                log('Initializing Golden Ratio System...');
                
                clock = new THREE.Clock();
                
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0xf0f8ff, 50, 200);
                
                camera = new THREE.PerspectiveCamera(
                    PHI * 45,
                    window.innerWidth / window.innerHeight, 
                    PHI_INV, 
                    1000
                );
                camera.position.set(0, 0, PHI * 30);
                
                const canvas = document.getElementById('three-canvas');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    alpha: true,
                    antialias: window.devicePixelRatio === 1,
                    powerPreference: "high-performance",
                    stencil: false,
                    depth: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                renderer.shadowMap.enabled = false;
                renderer.sortObjects = true;
                renderer.outputEncoding = THREE.LinearEncoding;
                
                log('Renderer created');
                
                const ambientLight = new THREE.AmbientLight(0xffffff, PHI_INV);
                scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0x7ec8e3, 1);
                dirLight.position.set(PHI * 5, PHI * 5, PHI * 5);
                scene.add(dirLight);
                
                log('Lighting added');
                
                harmonicMotion = new HarmonicMotionSystem();
                panelPhysics = new GoldenPanelPhysics();
                dataStreamController = new DataStreamController();
                
                createGoldenStructures();
                
                document.addEventListener('mousemove', onMouseMove, { passive: true });
                window.addEventListener('resize', onWindowResize, { passive: true });
                
                log('Starting Animation...');
                animate();
                
                setTimeout(() => {
                    debug.style.display = 'none';
                }, PHI * 2000);
                
            } catch(error) {
                log('Error: ' + error.message);
                console.error(error);
            }
        }
        
        function createGoldenStructures() {
            log('Creating Iridescent Structures...');
            
            let sharedShader = null;
            
            function createIridescentMaterial(hueOffset = 0) {
                const material = new THREE.MeshPhysicalMaterial({
                    color: new THREE.Color().setHSL(hueOffset, 0.8, 0.6),
                    metalness: 0.4,
                    roughness: 0.2,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.0,
                    reflectivity: 0.8,
                    emissive: new THREE.Color().setHSL(hueOffset + 0.5, 1, 0.2),
                    emissiveIntensity: 0.3,
                    side: THREE.DoubleSide
                });
                
                material.userData = {
                    hueOffset: hueOffset,
                    time: 0,
                    shader: null
                };
                
                material.onBeforeCompile = function(shader) {
                    if (!sharedShader) {
                        shader.uniforms.time = { value: 0 };
                        
                        shader.vertexShader = 'varying vec3 vWorldNormal;\n' + shader.vertexShader;
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <worldpos_vertex>',
                            `#include <worldpos_vertex>
                            vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);`
                        );
                        
                        shader.fragmentShader = 'uniform float time;\nvarying vec3 vWorldNormal;\n' + shader.fragmentShader;
                        shader.fragmentShader = shader.fragmentShader.replace(
                            '#include <color_fragment>',
                            `#include <color_fragment>
                            vec3 viewDirection = normalize(cameraPosition - vWorldPosition.xyz);
                            float fresnel = 1.0 - abs(dot(viewDirection, vWorldNormal));
                            
                            vec3 iridescentColor = vec3(
                                sin(fresnel * 6.28 + time * 2.0) * 0.5 + 0.5,
                                sin(fresnel * 6.28 + time * 2.5 + 2.094) * 0.5 + 0.5,
                                sin(fresnel * 6.28 + time * 3.0 + 4.189) * 0.5 + 0.5
                            );
                            
                            diffuseColor.rgb = mix(diffuseColor.rgb, iridescentColor, fresnel * 0.6);
                            diffuseColor.rgb += iridescentColor * fresnel * 0.3;`
                        );
                        
                        sharedShader = shader;
                    } else {
                        Object.assign(shader.uniforms, sharedShader.uniforms);
                        shader.vertexShader = sharedShader.vertexShader;
                        shader.fragmentShader = sharedShader.fragmentShader;
                    }
                    
                    material.userData.shader = shader;
                };
                
                return material;
            }
            
            function createWireframeMaterial(color = 0x7ec8e3) {
                return new THREE.MeshBasicMaterial({
                    color: color,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.1,
                    blending: THREE.AdditiveBlending
                });
            }
            
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0,
                roughness: 0,
                transmission: 0.9,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                ior: 1.5,
                reflectivity: 0.5
            });
            
            const structureCount = FIBONACCI[7];
            
            const positions = [
                { x: 61.8, y: 38.2, z: -20 },  
                { x: -38.2, y: -61.8, z: -40 }, 
                { x: 33.3, y: 66.7, z: -30 },
                { x: -66.7, y: 33.3, z: -25 },
                { x: 85.4, y: 85.4, z: -45 },
                { x: -85.4, y: -85.4, z: -35 },
                { x: -85.4, y: 85.4, z: -50 },
                { x: 85.4, y: -85.4, z: -40 },
                { x: 0, y: 76.4, z: -60 },
                { x: -76.4, y: 0, z: -55 },
                { x: 76.4, y: 0, z: -65 },
                { x: 0, y: -76.4, z: -70 },
                { x: 50, y: -50, z: -80 }
            ];
            
            for (let i = 0; i < structureCount; i++) {
                let geometry;
                let material;
                
                const isIridescent = i % 2 === 0;
                
                if (isIridescent) {
                    const hueOffset = (i / structureCount) * 0.3;
                    material = createIridescentMaterial(hueOffset);
                } else {
                    material = glassMaterial;
                }
                
                const sizeIndex = (i % 6) + 3;
                const baseSize = FIBONACCI[sizeIndex] * 0.5;
                
                const posIndex = i % positions.length;
                const pos = positions[posIndex];
                
                const depthScale = 1 - (Math.abs(pos.z) / 100) * 0.3;
                const size = baseSize * depthScale;
                
                const detailLevel = Math.abs(pos.z) > 50 ? 0 : 1;
                
                switch(i % 5) {
                    case 0:
                        geometry = new THREE.IcosahedronGeometry(size, detailLevel);
                        break;
                    case 1:
                        geometry = new THREE.TorusKnotGeometry(size * PHI_INV, size * 0.3, 55, 8, 2, 3);
                        break;
                    case 2:
                        geometry = new THREE.DodecahedronGeometry(size, 0);
                        break;
                    case 3:
                        geometry = new THREE.OctahedronGeometry(size, detailLevel);
                        break;
                    case 4:
                        geometry = new THREE.TetrahedronGeometry(size * PHI, Math.min(2, detailLevel + 1));
                        break;
                }
                
                const mesh = new THREE.Mesh(geometry, material);
                
                if (isIridescent) {
                    const wireframeMat = createWireframeMaterial();
                    const wireframeMesh = new THREE.Mesh(geometry, wireframeMat);
                    mesh.add(wireframeMesh);
                }
                
                mesh.position.set(pos.x, pos.y, pos.z);
                
                mesh.userData.originalPosition = mesh.position.clone();
                mesh.userData.isIridescent = isIridescent;
                mesh.frustumCulled = true;
                
                const patterns = ['sine', 'lissajous', 'perlin'];
                const axes = ['x', 'y', 'z'];
                
                harmonicMotion.registerElement(mesh, {
                    amplitude: FIBONACCI[sizeIndex % 5 + 1] * (0.5 + Math.random() * 0.5),
                    frequency: 1 / (FIBONACCI[sizeIndex % 4 + 3] * (1.5 + Math.random())),
                    phase: i * PHI + Math.random() * Math.PI,
                    axis: axes[i % 3],
                    pattern: patterns[Math.floor(i / 3) % 3]
                });
                
                scene.add(mesh);
                structures.push(mesh);
                
                perfMonitor.objectCount++;
            }
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x7ec8e3, 1);
            directionalLight.position.set(30, 30, 30);
            scene.add(directionalLight);
            
            const secondaryLight = new THREE.PointLight(0xa8d5e8, 0.8, 100);
            secondaryLight.position.set(-30, -30, 30);
            scene.add(secondaryLight);
            
            log(`Created ${structures.length} structures`);
        }
        
        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const cursor = document.getElementById('chromeCursor');
            cursor.style.left = event.clientX + 'px';
            cursor.style.top = event.clientY + 'px';
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (panelPhysics) {
                panelPhysics.updateBounds();
            }
            
            if (dataStreamController) {
                dataStreamController.updateStreams();
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();
            
            perfMonitor.update();
            
            if (harmonicMotion) {
                harmonicMotion.update(deltaTime);
            }
            
            if (panelPhysics) {
                panelPhysics.update(deltaTime);
            }
            
            const rotationSpeedX = deltaTime * PHI_INV * 0.1;
            const rotationSpeedY = deltaTime * PHI_INV * 0.2;
            
            for (let i = 0; i < structures.length; i++) {
                const structure = structures[i];
                
                if (!structure.visible) continue;
                
                structure.rotation.x += rotationSpeedX * (1 + i * 0.1);
                structure.rotation.y += rotationSpeedY * (1 + i * 0.05);
                
                if (structure.userData.isIridescent && 
                    structure.material.userData.shader && 
                    Math.floor(time * 60) % 3 === 0) {
                    structure.material.userData.shader.uniforms.time.value = time;
                }
            }
            
            const camTime1 = time * PHI_INV * 0.1;
            const camTime2 = time * PHI_INV * 0.08;
            const camTime3 = time * PHI_INV * 0.05;
            
            camera.position.x = Math.sin(camTime1) * PHI * 2;
            camera.position.y = Math.cos(camTime2) * PHI + 2;
            camera.position.z = PHI * 30 + Math.sin(camTime3) * PHI * 3;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        function createNeuralNetwork() {
            const network = document.getElementById('neuralNetwork');
            const elements = document.querySelectorAll('.shape-cluster, .nav-panel');
            const nodes = [];
            
            const fragment = document.createDocumentFragment();
            
            elements.forEach((element, index) => {
                const rect = element.getBoundingClientRect();
                const node = document.createElement('div');
                node.className = 'neural-node';
                node.style.cssText = `
                    position: absolute;
                    width: ${FIBONACCI[3] * 2}px;
                    height: ${FIBONACCI[3] * 2}px;
                    left: ${rect.left + rect.width / 2}px;
                    top: ${rect.top + rect.height / 2}px;
                    background: radial-gradient(circle, var(--accent-cyan), transparent);
                    border-radius: 50%;
                    box-shadow: 0 0 ${FIBONACCI[5]}px rgba(126,200,227,0.5);
                    animation: pulse ${PHI * 2}s infinite;
                    will-change: transform;
                    transform: translateZ(0);
                `;
                fragment.appendChild(node);
                nodes.push({
                    element: node,
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                });
            });
            
            for(let i = 0; i < nodes.length; i++) {
                for(let j = i + 1; j < nodes.length; j++) {
                    if(Math.random() > PHI_INV * 1.2) {
                        const strand = document.createElement('div');
                        strand.className = 'neural-strand';
                        
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        strand.style.cssText = `
                            position: absolute;
                            height: 1px;
                            background: linear-gradient(90deg, 
                                transparent, 
                                var(--accent-cyan) ${PHI_INV * 30}%, 
                                var(--accent-cyan) ${(1 - PHI_INV * 0.3) * 100}%, 
                                transparent);
                            width: ${distance}px;
                            left: ${nodes[i].x}px;
                            top: ${nodes[i].y}px;
                            transform: rotate(${angle}deg);
                            transform-origin: 0 50%;
                            opacity: ${PHI_INV * 0.5};
                            animation: neural-pulse ${FIBONACCI[5]}s infinite;
                            animation-delay: ${Math.random() * FIBONACCI[5]}s;
                            will-change: opacity;
                        `;
                        
                        fragment.appendChild(strand);
                    }
                }
            }
            
            network.appendChild(fragment);
        }
        
        const style = document.createElement('style');
        style.textContent = `
            @keyframes neural-pulse {
                0%, 100% { opacity: ${PHI_INV * 0.2}; }
                50% { opacity: ${PHI_INV * 0.8}; }
            }
            @keyframes pulse {
                0%, 100% { transform: scale(1); opacity: ${PHI_INV}; }
                50% { transform: scale(${PHI}); opacity: 1; }
            }
        `;
        document.head.appendChild(style);
        
        window.addEventListener('load', () => {
            createNeuralNetwork();
        });
        
        checkThreeJS();
        
        // ============================================
        // PANEL EXPANSION SYSTEM - ADVANCED MORPHING
        // ============================================
        
        let currentExpandedPanel = null;
        let isExpanded = false;
        
        function expandPanel(panelId, contentType) {
            if (isExpanded) return;
            isExpanded = true;
            currentExpandedPanel = panelId;
            
            const panel = document.getElementById(panelId);
            const expandedOverlay = document.getElementById('expandedOverlay');
            const expandedContainer = document.getElementById('expandedContainer');
            const expandedContent = document.getElementById('expandedContent');
            
            // Clear any inline opacity styles
            panel.style.opacity = '';
            
            // Get panel's current position
            const panelRect = panel.getBoundingClientRect();
            const panelData = panelPhysics.panels.get(panelId);
            
            // Set initial position to match the panel
            expandedContainer.style.left = panelRect.left + 'px';
            expandedContainer.style.top = panelRect.top + 'px';
            expandedContainer.style.width = panelRect.width + 'px';
            expandedContainer.style.height = panelRect.height + 'px';
            expandedContainer.style.opacity = '1';
            
            // Disable physics for the expanding panel
            if (panelData) {
                panelData.isDragging = true; // Prevent physics updates
            }
            
            // Load content based on type
            loadContent(contentType, expandedContent);
            
            // Start the expansion animation
            expandedOverlay.classList.add('active');
            
            // Force a reflow to ensure initial styles are applied
            expandedContainer.offsetHeight;
            
            // Add morphing class and expanded state
            expandedContainer.classList.add('morphing');
            requestAnimationFrame(() => {
                expandedContainer.classList.add('expanded');
                
                // Fade out all elements smoothly
                fadeOutElements();
                
                // Hide the clicked panel with fade transition
                panel.classList.add('hidden');
            });
            
            // Disable panel dragging during expansion
            document.querySelectorAll('.nav-panel').forEach(p => {
                p.style.pointerEvents = 'none';
            });
        }
        
        function collapsePanel() {
            if (!isExpanded) return;
            
            const expandedOverlay = document.getElementById('expandedOverlay');
            const expandedContainer = document.getElementById('expandedContainer');
            const panel = document.getElementById(currentExpandedPanel);
            
            // Get panel's current position for morphing back
            const panelRect = panel.getBoundingClientRect();
            
            // Remove expanded state to trigger morphing animation
            expandedContainer.classList.remove('expanded');
            
            // Morph back to panel position
            requestAnimationFrame(() => {
                expandedContainer.style.left = panelRect.left + 'px';
                expandedContainer.style.top = panelRect.top + 'px';
                expandedContainer.style.width = panelRect.width + 'px';
                expandedContainer.style.height = panelRect.height + 'px';
                
                // Fade in all elements smoothly
                fadeInElements();
                
                // Show the original panel with fade transition
                panel.classList.remove('hidden');
            });
            
            // Hide overlay after animation
            setTimeout(() => {
                expandedOverlay.classList.remove('active');
                expandedContainer.classList.remove('morphing');
                expandedContainer.style.opacity = '0';
                
                // Re-enable physics for the panel
                const panelData = panelPhysics.panels.get(currentExpandedPanel);
                if (panelData) {
                    panelData.isDragging = false;
                }
                
                // Re-enable panel dragging
                document.querySelectorAll('.nav-panel').forEach(p => {
                    p.style.pointerEvents = 'auto';
                });
                
                isExpanded = false;
                currentExpandedPanel = null;
            }, 800); // Match animation duration
        }
        
        function fadeOutElements() {
            // Fade out title, subtitle, and other panels
            document.getElementById('siteTitle').classList.add('hidden');
            document.getElementById('siteSubtitle').classList.add('hidden');
            
            document.querySelectorAll('.nav-panel').forEach(panel => {
                if (panel.id !== currentExpandedPanel) {
                    panel.classList.add('hidden');
                }
            });
        }
        
        function fadeInElements() {
            // Fade in title, subtitle, and all panels
            document.getElementById('siteTitle').classList.remove('hidden');
            document.getElementById('siteSubtitle').classList.remove('hidden');
            
            document.querySelectorAll('.nav-panel').forEach(panel => {
                // Clear any inline opacity styles
                panel.style.opacity = '';
                panel.classList.remove('hidden');
            });
        }
        
        function loadContent(contentType, container) {
            switch(contentType) {
                case 'leadership':
                    container.innerHTML = getLeadershipContent();
                    break;
                case 'research':
                    container.innerHTML = getResearchContent();
                    break;
                case 'workshops':
                    container.innerHTML = getWorkshopsContent();
                    break;
                case 'community':
                    container.innerHTML = getCommunityContent();
                    break;
                case 'join':
                    container.innerHTML = getJoinContent();
                    break;
                default:
                    container.innerHTML = '<p>Content coming soon...</p>';
            }
        }
        
        function getLeadershipContent() {
            return `
                <h1 class="expanded-title">NSCC Leadership</h1>
                
                <div class="leader-section">
                    <div class="leader-image leader-image-left">
                        <span><img src="DSC04788.jpg" alt="William Keffer"></span>
                    </div>
                    <div class="leader-info leader-info-left">
                        <div class="leader-role">Co-President</div>
                        <div class="leader-name">William Keffer</div>
                        <div class="leader-description">
                            William Keffer is a UNC-Chapel Hill student and the driving force behind the Natural Sciences Computing Club (NSCC), where he bridges natural sciences with modern computing through hands-on workshops, project sprints, and mentorship. He focuses on practical Python and Jupyter workflows, data visualization, and approachable machine learning—helping members turn curiosity into portfolio-ready projects that mix biology, physics, and earth science with code. With a sharp eye for design and user experience, William also shapes NSCC’s brand and web presence, championing creative, high-quality visuals alongside clean, reproducible pipelines. Above all, he’s building an inclusive, collaborative community that celebrates both scientific rigor and inventive, real-world problem-solving.
                        </div>
                    </div>
                </div>
                
                <div class="leader-section">
                    <div class="leader-info leader-info-right">
                        <div class="leader-role">Co-President</div>
                        <div class="leader-name">Osman Taka</div>
                        <div class="leader-description">
                            Osman Taka is a Computer Science and Physics double major at UNC Chapel Hill with a passion for using computational tools to tackle challenges in the natural sciences. He's drawn to projects that merge programming with scientific research—whether that's modeling complex systems or developing tools that make discovery more accessible. With experience leading robotics, math, and engineering initiatives, Osman values collaboration and creative problem-solving. Through the Natural Sciences Computing Club, he hopes to build a community where students from different disciplines can explore the intersection of computation and science, and work together on projects that make a real impact.
                        </div>
                    </div>
                    <div class="leader-image leader-image-right">
                        <span><img src="ot.jpg" alt="Osman Taka"></span>
                    </div>
                </div>
                
                <div class="leader-section">
                    <div class="leader-image leader-image-left">
                        <span><img src="JC_photo.jpg" alt="John Christopher"></span>
                    </div>
                    <div class="leader-info leader-info-left">
                        <div class="leader-role">Treasurer</div>
                        <div class="leader-name">John Christopher</div>
                        <div class="leader-description">
                            John Christopher is a second-year Mathematics student at the University of North Carolina at Chapel Hill. He is interested in differential geometry and mathematical physics, focusing on the connections between mathematical theory and the physical world. John aims to integrate mathematical modeling and computational methods to deepen understanding of complex natural systems. Through the Natural Sciences Computing Club, he hopes to help foster collaboration between mathematics and the natural sciences.
                        </div>
                    </div>
                </div>
                
                <div class="bottom-link">
                    <a href="#" onclick="return false;">2025-26 Officer Positions</a>
                </div>
            `;
        }
        
        function getResearchContent() {
            return `
                <h1 class="expanded-title">Research Projects</h1>
                <p style="text-align: center; margin-bottom: 40px; color: var(--text-light);">
                    Cutting-edge computational research across natural sciences
                </p>
                <div class="bottom-link">
                    <a href="#" onclick="return false;">Join a Research Team</a>
                </div>
            `;
        }
        
        function getWorkshopsContent() {
            return `
                <h1 class="expanded-title">Workshops & Training</h1>
                <p style="text-align: center; margin-bottom: 40px; color: var(--text-light);">
                    Weekly sessions on computational tools and techniques
                </p>
                <div class="bottom-link">
                    <a href="#" onclick="return false;">View Schedule</a>
                </div>
            `;
        }
        
        function getCommunityContent() {
            return `
                <h1 class="expanded-title">Our Community</h1>
                <p style="text-align: center; margin-bottom: 40px; color: var(--text-light);">
                    Connect with students passionate about computational science
                </p>
                <div class="bottom-link">
                    <a href="#" onclick="return false;">Join Discord</a>
                </div>
            `;
        }
        
        function getJoinContent() {
            return `
                <h1 class="expanded-title">Join NSCC</h1>
                <p style="text-align: center; margin-bottom: 40px; color: var(--text-light);">
                    Open to all UNC students - no experience required!
                </p>
                <div class="bottom-link">
                    <a href="#" onclick="return false;">Apply Now</a>
                </div>
            `;
        }
        
        console.log('%c✦ GOLDEN RATIO CYBERCORE INITIALIZED', 
            'color: #7ec8e3; font-size: 24px; font-weight: 100; text-shadow: 0 0 20px rgba(126,200,227,0.8);');
        console.log(`%c→ φ = ${PHI.toFixed(3)}`, 'color: #a8d5e8; font-size: 12px;');
        console.log(`%c→ Fibonacci: ${FIBONACCI.slice(0, 8).join(', ')}...`, 'color: #a8d5e8; font-size: 12px;');
    </script>
</body>
</html>